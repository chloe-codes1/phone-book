{"version":3,"sources":["components/PhoneForm.js","components/PhoneInfo.js","components/PhoneInfoList.js","App.js","serviceWorker.js","index.js"],"names":["PhoneForm","state","name","phone","handleChange","e","setState","target","value","handleSubmit","preventDefault","props","onCreate","onSubmit","this","placeholder","onChange","type","Component","PhoneInfo","editing","handleRemove","info","onRemove","id","handleToggleEdit","prevProps","prevState","onUpdate","nextProps","nextState","console","log","myStyle","border","padding","margin","style","onClick","defaultProps","PhoneInfoList","data","list","map","key","warn","App","information","keyword","handleCreate","concat","filter","handleUpdate","filteredList","indexOf","className","React","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.192b9942.chunk.js","sourcesContent":["import React, { Component } from 'react';\n\nclass PhoneForm extends Component{\n\n    state = {\n        name: '',\n        phone: ''\n    }\n\n    handleChange = (e) => {\n        this.setState({\n            // Computed Property Names ]\n            // : input에 name= \"\"\n            [e.target.name]: e.target.value\n        })\n    }\n\n    handleSubmit = (e) => {\n        //페이지 re-loading 방지\n        e.preventDefault();\n\n        //상태가앖을 onCreate를 통해 부모에게 전달\n        this.props.onCreate(this.state);\n\n        //상태 초기화\n        this.setState({\n            name: '',\n            phone: ''\n        })\n    }\n \n    render() {\n        return (\n            <form onSubmit={this.handleSubmit}>\n                <input placeholder=\"Your Name\" value={this.state.name} \n                       onChange={this.handleChange} name=\"name\"/>\n                <input placeholder=\"Your Phone Number\" value={this.state.phone} \n                       onChange={this.handleChange} name=\"phone\"/>\n                <button type=\"submit\"> Submit</button>\n            </form>\n\n        );\n    }\n}\n\nexport default PhoneForm;","import React, { Component } from \"react\";\n\nclass PhoneInfo extends Component {\n  // [ defaultProps 설정 ]\n  // : 만약 실수로 info를 전달해주지 않으면 Component가 crash 되므로 defaultProps를 설정해줌. Just in case!\n  static defaultProps = {\n    info: {\n      name: \"Name\",\n      phone: \"010-0000-0000\",\n      id: 0\n    }\n  };\n\n  // 수정 버튼을 눌렀을 때 editing을 true 로 설정 해줄 것임\n  // -> true 일때는 기본에 text로 보여주던 data를 input 형태로 보여줄 것이다!\n  state = {\n    editing: false,\n    name: \"\",\n    phone: \"\"\n    // -> input을 담기 위한 필드 설정\n  };\n\n  handleRemove = () => {\n    const { info, onRemove } = this.props;\n    onRemove(info.id);\n  };\n\n  //editing 을 반전시키는 함수\n  handleToggleEdit = () => {\n    const { editing } = this.state;\n    this.setState({ editing: !editing });\n  };\n\n  //input에서 onChange event 발생 시 호출되는 함수\n  handleChange = e => {\n    const { name, value } = e.target;\n    this.setState({\n      [name]: value\n    });\n  };\n\n  //editing이 바뀔 때 처리해야 할 로직\n  // 1) 수정 clicked -> 기존의 data가 input에 나타남\n  // 2) 수정 적용 -> input의 data를 부모 component에 전달\n  componentDidUpdate(prevProps, prevState) {\n    const { info, onUpdate } = this.props;\n\n    //editing이 false -> true로 전환될 때 info의 data를 state에 넣어준다\n    if (!prevState.editing && this.state.editing) {\n      this.setState({\n        name: info.name,\n        phone: info.phone\n      });\n    }\n\n    //editing이 true -> false로 전환 될 때\n    if (prevState.editing && !this.state.editing) {\n      onUpdate(info.id, {\n        name: this.state.name,\n        phone: this.state.phone\n      });\n    }\n  }\n\n  // Modify 상태가 아니고, info data가 동일하면 re-rendering 안하게 하는 역할\n  // => 검색 (filtering) 할 때 re-rendering 안하게 하려고!ㅛ \n  shouldComponentUpdate(nextProps, nextState){\n    if(!this.state.editing \n       && !nextState.editing\n       && nextProps.info === this.props.info){\n        return false;\n          // -> 수정중 아니고 동일하면 re-rendering 하지 마라\n       }\n\n       return true;\n         // -> 나머지 경우엔 re-rendering 해라\n  }\n\n  render() {\n    console.log(\"Render PhoneInfo => id:\" +this.props.info.id)\n\n    const myStyle = {\n      border: \"1px solid gray\",\n      padding: \"8px\",\n      margin: \"8px\"\n    };\n\n  // [ 수정 시 ]\n\n  const {editing} = this.state;\n\n  if (editing) {\n    return (\n      <div style = {myStyle}>\n        <div>\n        <input value={this.state.name}\n               name=\"name\"\n               placeholder=\"Name\"\n               onChange={this.handleChange}\n               />\n        </div>\n        <div>\n        <input value={this.state.phone}\n               name=\"phone\"\n               placeholder=\"Phone Number\"\n               onChange={this.handleChange}\n        />  \n        </div>\n        <button onClick={this.handleToggleEdit}>Submit</button>\n        <button onClick={this.handleRemove}>Delete</button>\n      </div>\n    )\n  }\n\n    // [ 일반 모드 ]\n    const { name, phone /*id*/ } = this.props.info;\n\n    return (\n      <div style={myStyle}>\n        <div>\n          <b>{name}</b>\n        </div>\n        <div>{phone}</div>\n        <button onClick={this.handleToggleEdit}>Modify</button>\n        <button onClick={this.handleRemove}>Delete</button>\n      </div>\n    );\n  }\n}\n\nexport default PhoneInfo;\n","import React, {Component} from 'react';\nimport PhoneInfo from './PhoneInfo';\n\nclass PhoneInfoList extends Component {\n\n    static defaultProps = {\n        list: [],\n        onRemove: () => console.warn('onRemove not defined!'),\n        onUpdate: () => console.warn('onUpdate not defined!')\n    }\n\n    // Modify 시 App.js가 re-rendering 됨에 따라 변화가 없는 PhoneInfoList도 re-rendering 되므로,\n    // LifeCycle API를 사용하여 Virtual DOM에 Rendering 하는 자원을 아끼는 것이 좋다!\n    shouldComponentUpdate(nextProps, nextState){\n        \n        // 다음 받아올 data가 현재 data랑 다른 배열일 때 true로 설정\n        return nextProps.data !== this.props.data;\n                // -> 변화가 필요하지 않으면 render() 가 호출되지 않음\n                // -> 이렇게 단순하게 할 수 있는 이유는 불변성을 지켜줬기 때문!\n                //    ex) 배열을 복사하여 수정하면 실제로는 복사가 아니라 동일한 배열을 가리키고 있는 reference가 하나 더 만들어 지는 것\n                //        => 그래서 새로운 배열을 만들어서 추가함!\n    }\n\n    render() {\n        console.log(\"Render PhoneInfoList\")\n        const {data, onRemove, onUpdate} = this.props;\n        const list = data.map(\n            info => (<PhoneInfo \n                        key={info.id} \n                        info={info} \n                        onRemove = {onRemove}\n                        onUpdate = {onUpdate}/>)\n                            // [ key를 따로 설정하는 이유 ]\n                            // : key를 따로 설정하지 않으면 배열의 index가 자동으로 key로 설정 되지만,\n                            //   update 시에 효율적이지 않음\n                            //    -> update 성능 최적화를 위해 key를 설정한다!\n                            //       => 배열을 rendering 할때에는 고유가앖을 key로 사용해아 한다!\n        );\n\n        return (\n            <div>\n                {list}\n            </div>\n        );\n    }\n}\nexport default PhoneInfoList;","import React from \"react\";\nimport PhoneForm from \"./components/PhoneForm\";\nimport PhoneInfoList from \"./components/PhoneInfoList\";\n\nclass App extends React.Component {\n\n  id = 2\n  state = {\n    information: [\n      {\n        id: 0,\n        name: 'Chloe',\n        phone: '010-0000-0000'\n      },\n      {\n        id:1,\n        name: 'Camila',\n        phone: '010-0000-0000'\n      }\n    ],\n    keyword: ''\n  }\n\n  //search\n  handleChange = (e) => {\n    this.setState({\n      keyword: e.target.value\n    });\n  }\n\n  //insert\n  handleCreate = (data) => {\n    console.log(data);\n    const { information } = this.state;\n    this.setState({\n      information: information.concat({ id: this.id++, ...data})\n                    // [ concat() method ]\n                    // : used to merge two or more arrays. \n                    //  -> This method does not change the existing arrays \n                    //     but, instead returns a new array.\n    })\n  }\n\n  //delete\n  handleRemove = (id) => {\n    console.log(id);\n    const {information} = this.state;\n    this.setState({\n      information: information.filter(info => info.id !==id)\n    })\n  }\n\n  //update\n  handleUpdate = (id, data) => {\n    console.log(id);\n    console.log(data);\n    const {information} = this.state;\n    this.setState({\n      information: information.map( \n        info => id === info.id \n        ? {...info, ...data} //새 객체를 만들어서 기존의 data를 전달받은 data로 덮어씀\n        : info ) //기존의 data를 그대로 유지\n    })  \n  }\n\n  render() {\n    const {information, keyword} = this.state;\n    const filteredList = information.filter(\n      info => info.name.indexOf(keyword) !== -1\n    );\n\n    return (\n      <div className=\"App\">\n        <PhoneForm onCreate={this.handleCreate} />\n        <br/>\n       \n      {/*   {JSON.stringify(information)} */}\n         {/* -> information 가앖을 문자열로 변환하기 */}\n\n        <input placeholder=\"Find a person by name\"\n               onChange={this.handleChange}\n               value={keyword}/>\n\n         <PhoneInfoList data = {filteredList}\n                        onRemove={this.handleRemove}\n                        onUpdate={this.handleUpdate}/>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}